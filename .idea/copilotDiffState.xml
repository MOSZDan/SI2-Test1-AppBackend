<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/api/services/ai_detection.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api/services/ai_detection.py" />
              <option name="originalContent" value="# api/services/ai_detection.py&#10;import cv2&#10;import face_recognition&#10;import numpy as np&#10;import json&#10;import base64&#10;import io&#10;from PIL import Image&#10;import easyocr&#10;import re&#10;from typing import List, Tuple, Optional, Dict&#10;from django.conf import settings&#10;from ..models import Usuario, PerfilFacial, ReconocimientoFacial, DeteccionPlaca, Vehiculo&#10;from .supabase_storage import SupabaseStorageService&#10;import logging&#10;from django.core.files.uploadedfile import InMemoryUploadedFile&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;class FacialRecognitionService:&#10;    &quot;&quot;&quot;Servicio para reconocimiento facial usando face_recognition&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.tolerance = settings.AI_IMAGE_SETTINGS.get('FACE_TOLERANCE', 0.6)&#10;        self.known_encodings = []&#10;        self.known_users = []&#10;        self.storage_service = SupabaseStorageService()&#10;        self.load_known_faces()&#10;&#10;    def load_known_faces(self):&#10;        &quot;&quot;&quot;Carga las caras conocidas desde la base de datos&quot;&quot;&quot;&#10;        try:&#10;            perfiles = PerfilFacial.objects.filter(activo=True).select_related('codigo_usuario')&#10;&#10;            self.known_encodings = []&#10;            self.known_users = []&#10;&#10;            for perfil in perfiles:&#10;                try:&#10;                    encoding = np.array(json.loads(perfil.encoding_facial))&#10;                    self.known_encodings.append(encoding)&#10;                    self.known_users.append(perfil.codigo_usuario)&#10;                except Exception as e:&#10;                    logger.error(f&quot;Error cargando perfil facial {perfil.id}: {e}&quot;)&#10;&#10;            logger.info(f&quot;Cargados {len(self.known_encodings)} perfiles faciales&quot;)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error cargando caras conocidas: {e}&quot;)&#10;&#10;    def register_face(self, user_id: int, image_base64: str) -&gt; bool:&#10;        &quot;&quot;&quot;Registra una nueva cara en el sistema&quot;&quot;&quot;&#10;        try:&#10;            image = self._base64_to_image(image_base64)&#10;            if image is None:&#10;                return False&#10;&#10;            face_locations = face_recognition.face_locations(image)&#10;            if not face_locations:&#10;                logger.warning(&quot;No se detectó ninguna cara en la imagen&quot;)&#10;                return False&#10;&#10;            face_encodings = face_recognition.face_encodings(image, face_locations)&#10;            if not face_encodings:&#10;                logger.warning(&quot;No se pudo generar encoding facial&quot;)&#10;                return False&#10;&#10;            encoding = face_encodings[0]&#10;&#10;            upload_result = self.storage_service.upload_base64_image(&#10;                image_base64,&#10;                folder=&quot;profiles&quot;,&#10;                prefix=f&quot;user_{user_id}&quot;&#10;            )&#10;&#10;            if not upload_result:&#10;                logger.error(&quot;Error subiendo imagen a Supabase&quot;)&#10;                return False&#10;&#10;            usuario = Usuario.objects.get(codigo=user_id)&#10;            perfil, created = PerfilFacial.objects.get_or_create(&#10;                codigo_usuario=usuario,&#10;                defaults={&#10;                    'encoding_facial': json.dumps(encoding.tolist()),&#10;                    'imagen_path': upload_result['file_path'],&#10;                    'imagen_url': upload_result['public_url'],&#10;                    'activo': True&#10;                }&#10;            )&#10;&#10;            if not created:&#10;                if perfil.imagen_path:&#10;                    self.storage_service.delete_file(perfil.imagen_path)&#10;&#10;                perfil.encoding_facial = json.dumps(encoding.tolist())&#10;                perfil.imagen_path = upload_result['file_path']&#10;                perfil.imagen_url = upload_result['public_url']&#10;                perfil.activo = True&#10;                perfil.save()&#10;&#10;            self.load_known_faces()&#10;&#10;            logger.info(f&quot;Cara registrada para usuario {user_id}&quot;)&#10;            return True&#10;&#10;        except Usuario.DoesNotExist:&#10;            logger.error(f&quot;Usuario {user_id} no existe&quot;)&#10;            return False&#10;        except Exception as e:&#10;            logger.error(f&quot;Error registrando cara: {e}&quot;)&#10;            return False&#10;&#10;    def recognize_face(self, image_base64: str, camera_location: str = &quot;Principal&quot;) -&gt; Dict:&#10;        &quot;&quot;&quot;Reconoce una cara en la imagen&quot;&quot;&quot;&#10;        try:&#10;            image = self._base64_to_image(image_base64)&#10;            if image is None:&#10;                return self._create_recognition_result(False, None, 0.0, image_base64, camera_location)&#10;&#10;            face_locations = face_recognition.face_locations(image)&#10;            if not face_locations:&#10;                return self._create_recognition_result(False, None, 0.0, image_base64, camera_location)&#10;&#10;            face_encodings = face_recognition.face_encodings(image, face_locations)&#10;            if not face_encodings:&#10;                return self._create_recognition_result(False, None, 0.0, image_base64, camera_location)&#10;&#10;            for face_encoding in face_encodings:&#10;                if not self.known_encodings:&#10;                    break&#10;&#10;                matches = face_recognition.compare_faces(&#10;                    self.known_encodings, face_encoding, tolerance=self.tolerance&#10;                )&#10;                face_distances = face_recognition.face_distance(&#10;                    self.known_encodings, face_encoding&#10;                )&#10;&#10;                if any(matches):&#10;                    best_match_index = np.argmin(face_distances)&#10;                    if matches[best_match_index]:&#10;                        usuario = self.known_users[best_match_index]&#10;                        confidence = (1 - face_distances[best_match_index]) * 100&#10;&#10;                        return self._create_recognition_result(&#10;                            True, usuario, confidence, image_base64, camera_location&#10;                        )&#10;&#10;            return self._create_recognition_result(False, None, 0.0, image_base64, camera_location)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error en reconocimiento facial: {e}&quot;)&#10;            return self._create_recognition_result(False, None, 0.0, image_base64, camera_location)&#10;&#10;    def _create_recognition_result(self, is_resident: bool, usuario: Optional[Usuario],&#10;                                   confidence: float, image_base64: str, camera_location: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Crea y guarda el resultado del reconocimiento&quot;&quot;&quot;&#10;        try:&#10;            upload_result = self.storage_service.upload_base64_image(&#10;                image_base64,&#10;                folder=&quot;facial&quot;,&#10;                prefix=f&quot;detection_{camera_location.lower().replace(' ', '_')}&quot;&#10;            )&#10;&#10;            reconocimiento = ReconocimientoFacial.objects.create(&#10;                codigo_usuario=usuario,&#10;                imagen_path=upload_result['file_path'] if upload_result else None,&#10;                imagen_url=upload_result['public_url'] if upload_result else None,&#10;                confianza=confidence,&#10;                es_residente=is_resident,&#10;                ubicacion_camara=camera_location,&#10;                estado='permitido' if is_resident else 'denegado'&#10;            )&#10;&#10;            return {&#10;                'id': reconocimiento.id,&#10;                'is_resident': is_resident,&#10;                'user': {&#10;                    'codigo': usuario.codigo if usuario else None,&#10;                    'nombre': f&quot;{usuario.nombre} {usuario.apellido}&quot; if usuario else &quot;Desconocido&quot;,&#10;                    'correo': usuario.correo if usuario else None&#10;                } if usuario else None,&#10;                'confidence': round(confidence, 2),&#10;                'timestamp': reconocimiento.fecha_deteccion.isoformat(),&#10;                'camera_location': camera_location,&#10;                'status': 'permitido' if is_resident else 'denegado',&#10;                'image_url': reconocimiento.imagen_url&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creando resultado de reconocimiento: {e}&quot;)&#10;            return {&#10;                'id': None,&#10;                'is_resident': False,&#10;                'user': None,&#10;                'confidence': 0.0,&#10;                'timestamp': None,&#10;                'camera_location': camera_location,&#10;                'status': 'error',&#10;                'image_url': None&#10;            }&#10;&#10;    def _base64_to_image(self, base64_string: str) -&gt; Optional[np.ndarray]:&#10;        &quot;&quot;&quot;Convierte base64 a imagen numpy&quot;&quot;&quot;&#10;        try:&#10;            if base64_string.startswith('data:image'):&#10;                base64_string = base64_string.split(',', 1)[1]&#10;&#10;            image_data = base64.b64decode(base64_string)&#10;            image = Image.open(io.BytesIO(image_data))&#10;&#10;            if image.mode != 'RGB':&#10;                image = image.convert('RGB')&#10;&#10;            return np.array(image)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error convirtiendo base64 a imagen: {e}&quot;)&#10;            return None&#10;    def register_face_from_file(self, user_id: int, image_file: InMemoryUploadedFile) -&gt; bool:&#10;        &quot;&quot;&quot;Registra una nueva cara desde un archivo Django&quot;&quot;&quot;&#10;        try:&#10;            # Convertir archivo Django a imagen numpy&#10;            image = self._file_to_image(image_file)&#10;            if image is None:&#10;                return False&#10;&#10;            face_locations = face_recognition.face_locations(image)&#10;            if not face_locations:&#10;                logger.warning(&quot;No se detectó ninguna cara en la imagen&quot;)&#10;                return False&#10;&#10;            face_encodings = face_recognition.face_encodings(image, face_locations)&#10;            if not face_encodings:&#10;                logger.warning(&quot;No se pudo generar encoding facial&quot;)&#10;                return False&#10;&#10;            encoding = face_encodings[0]&#10;&#10;            # Subir archivo directamente a Supabase&#10;            upload_result = self.storage_service.upload_django_file(&#10;                image_file,&#10;                folder=&quot;profiles&quot;,&#10;                prefix=f&quot;user_{user_id}&quot;&#10;            )&#10;&#10;            if not upload_result:&#10;                logger.error(&quot;Error subiendo imagen a Supabase&quot;)&#10;                return False&#10;&#10;            usuario = Usuario.objects.get(codigo=user_id)&#10;            perfil, created = PerfilFacial.objects.get_or_create(&#10;                codigo_usuario=usuario,&#10;                defaults={&#10;                    'encoding_facial': json.dumps(encoding.tolist()),&#10;                    'imagen_path': upload_result['file_path'],&#10;                    'imagen_url': upload_result['public_url'],&#10;                    'activo': True&#10;                }&#10;            )&#10;&#10;            if not created:&#10;                if perfil.imagen_path:&#10;                    self.storage_service.delete_file(perfil.imagen_path)&#10;&#10;                perfil.encoding_facial = json.dumps(encoding.tolist())&#10;                perfil.imagen_path = upload_result['file_path']&#10;                perfil.imagen_url = upload_result['public_url']&#10;                perfil.activo = True&#10;                perfil.save()&#10;&#10;            self.load_known_faces()&#10;&#10;            logger.info(f&quot;Cara registrada para usuario {user_id}&quot;)&#10;            return True&#10;&#10;        except Usuario.DoesNotExist:&#10;            logger.error(f&quot;Usuario {user_id} no existe&quot;)&#10;            return False&#10;        except Exception as e:&#10;            logger.error(f&quot;Error registrando cara desde archivo: {e}&quot;)&#10;            return False&#10;&#10;    def recognize_face_from_file(self, image_file: InMemoryUploadedFile, camera_location: str = &quot;Principal&quot;) -&gt; Dict:&#10;        &quot;&quot;&quot;Reconoce una cara desde un archivo Django&quot;&quot;&quot;&#10;        try:&#10;            image = self._file_to_image(image_file)&#10;            if image is None:&#10;                return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;            face_locations = face_recognition.face_locations(image)&#10;            if not face_locations:&#10;                return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;            face_encodings = face_recognition.face_encodings(image, face_locations)&#10;            if not face_encodings:&#10;                return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;            for face_encoding in face_encodings:&#10;                if not self.known_encodings:&#10;                    break&#10;&#10;                matches = face_recognition.compare_faces(&#10;                    self.known_encodings, face_encoding, tolerance=self.tolerance&#10;                )&#10;                face_distances = face_recognition.face_distance(&#10;                    self.known_encodings, face_encoding&#10;                )&#10;&#10;                if any(matches):&#10;                    best_match_index = np.argmin(face_distances)&#10;                    if matches[best_match_index]:&#10;                        usuario = self.known_users[best_match_index]&#10;                        confidence = (1 - face_distances[best_match_index]) * 100&#10;&#10;                        return self._create_recognition_result_from_file(&#10;                            True, usuario, confidence, image_file, camera_location&#10;                        )&#10;&#10;            return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error en reconocimiento facial desde archivo: {e}&quot;)&#10;            return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;    def _create_recognition_result_from_file(self, is_resident: bool, usuario: Optional[Usuario],&#10;                                           confidence: float, image_file: InMemoryUploadedFile, camera_location: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Crea y guarda el resultado del reconocimiento desde archivo&quot;&quot;&quot;&#10;        try:&#10;            upload_result = self.storage_service.upload_django_file(&#10;                image_file,&#10;                folder=&quot;facial&quot;,&#10;                prefix=f&quot;detection_{camera_location.lower().replace(' ', '_')}&quot;&#10;            )&#10;&#10;            reconocimiento = ReconocimientoFacial.objects.create(&#10;                codigo_usuario=usuario,&#10;                imagen_path=upload_result['file_path'] if upload_result else None,&#10;                imagen_url=upload_result['public_url'] if upload_result else None,&#10;                confianza=confidence,&#10;                es_residente=is_resident,&#10;                ubicacion_camara=camera_location,&#10;                estado='permitido' if is_resident else 'denegado'&#10;            )&#10;&#10;            return {&#10;                'id': reconocimiento.id,&#10;                'is_resident': is_resident,&#10;                'user': {&#10;                    'codigo': usuario.codigo if usuario else None,&#10;                    'nombre': f&quot;{usuario.nombre} {usuario.apellido}&quot; if usuario else &quot;Desconocido&quot;,&#10;                    'correo': usuario.correo if usuario else None&#10;                } if usuario else None,&#10;                'confidence': round(confidence, 2),&#10;                'timestamp': reconocimiento.fecha_deteccion.isoformat(),&#10;                'camera_location': camera_location,&#10;                'status': 'permitido' if is_resident else 'denegado',&#10;                'image_url': reconocimiento.imagen_url&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creando resultado de reconocimiento desde archivo: {e}&quot;)&#10;            return {&#10;                'id': None,&#10;                'is_resident': False,&#10;                'user': None,&#10;                'confidence': 0.0,&#10;                'timestamp': None,&#10;                'camera_location': camera_location,&#10;                'status': 'error',&#10;                'image_url': None&#10;            }&#10;&#10;    def _file_to_image(self, image_file: InMemoryUploadedFile) -&gt; Optional[np.ndarray]:&#10;        &quot;&quot;&quot;Convierte archivo Django a imagen numpy&quot;&quot;&quot;&#10;        try:&#10;            image_file.seek(0)  # Asegurar que estamos al inicio del archivo&#10;            image_data = image_file.read()&#10;            image = Image.open(io.BytesIO(image_data))&#10;&#10;            if image.mode != 'RGB':&#10;                image = image.convert('RGB')&#10;&#10;            return np.array(image)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error convirtiendo archivo a imagen: {e}&quot;)&#10;            return None&#10;&#10;# En la clase PlateDetectionService, agregar estos métodos:&#10;&#10;    def detect_plate_from_file(self, image_file: InMemoryUploadedFile, camera_location: str = &quot;Estacionamiento&quot;,&#10;                              access_type: str = &quot;entrada&quot;) -&gt; Dict:&#10;        &quot;&quot;&quot;Detecta placa desde un archivo Django&quot;&quot;&quot;&#10;        try:&#10;            image = self._file_to_image(image_file)&#10;            if image is None:&#10;                return self._create_detection_result_from_file(None, False, 0.0, image_file,&#10;                                                             camera_location, access_type)&#10;&#10;            processed_image = self._preprocess_image(image)&#10;            results = self.reader.readtext(processed_image)&#10;&#10;            for (bbox, text, confidence) in results:&#10;                clean_text = self._clean_plate_text(text)&#10;&#10;                if self._is_valid_plate(clean_text) and confidence &gt; self.confidence_threshold:&#10;                    is_authorized = self._check_authorization(clean_text)&#10;&#10;                    return self._create_detection_result_from_file(&#10;                        clean_text, is_authorized, confidence * 100,&#10;                        image_file, camera_location, access_type&#10;                    )&#10;&#10;            return self._create_detection_result_from_file(None, False, 0.0, image_file,&#10;                                                         camera_location, access_type)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error en detección de placa desde archivo: {e}&quot;)&#10;            return self._create_detection_result_from_file(None, False, 0.0, image_file,&#10;                                                         camera_location, access_type)&#10;&#10;    def _create_detection_result_from_file(self, plate: Optional[str], is_authorized: bool,&#10;                                         confidence: float, image_file: InMemoryUploadedFile, camera_location: str,&#10;                                         access_type: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Crea y guarda el resultado de la detección desde archivo&quot;&quot;&quot;&#10;        try:&#10;            upload_result = self.storage_service.upload_django_file(&#10;                image_file,&#10;                folder=&quot;plates&quot;,&#10;                prefix=f&quot;{access_type}_{camera_location.lower().replace(' ', '_')}&quot;&#10;            )&#10;&#10;            vehiculo = None&#10;            if plate:&#10;                vehiculo = Vehiculo.objects.filter(nro_placa__iexact=plate).first()&#10;&#10;            deteccion = DeteccionPlaca.objects.create(&#10;                placa_detectada=plate or &quot;No detectada&quot;,&#10;                vehiculo=vehiculo,&#10;                imagen_path=upload_result['file_path'] if upload_result else None,&#10;                imagen_url=upload_result['public_url'] if upload_result else None,&#10;                confianza=confidence,&#10;                es_autorizado=is_authorized,&#10;                ubicacion_camara=camera_location,&#10;                tipo_acceso=access_type&#10;            )&#10;&#10;            return {&#10;                'id': deteccion.id,&#10;                'plate': plate,&#10;                'is_authorized': is_authorized,&#10;                'vehicle': {&#10;                    'id': vehiculo.id if vehiculo else None,&#10;                    'descripcion': vehiculo.descripcion if vehiculo else None,&#10;                    'estado': vehiculo.estado if vehiculo else None&#10;                } if vehiculo else None,&#10;                'confidence': round(confidence, 2),&#10;                'timestamp': deteccion.fecha_deteccion.isoformat(),&#10;                'camera_location': camera_location,&#10;                'access_type': access_type,&#10;                'status': 'autorizado' if is_authorized else 'no_autorizado',&#10;                'image_url': deteccion.imagen_url&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creando resultado de detección desde archivo: {e}&quot;)&#10;            return {&#10;                'id': None,&#10;                'plate': plate,&#10;                'is_authorized': False,&#10;                'vehicle': None,&#10;                'confidence': 0.0,&#10;                'timestamp': None,&#10;                'camera_location': camera_location,&#10;                'access_type': access_type,&#10;                'status': 'error',&#10;                'image_url': None&#10;            }&#10;&#10;    def _file_to_image(self, image_file: InMemoryUploadedFile) -&gt; Optional[np.ndarray]:&#10;        &quot;&quot;&quot;Convierte archivo Django a imagen numpy&quot;&quot;&quot;&#10;        try:&#10;            image_file.seek(0)&#10;            image_data = image_file.read()&#10;            image = Image.open(io.BytesIO(image_data))&#10;&#10;            if image.mode != 'RGB':&#10;                image = image.convert('RGB')&#10;&#10;            return np.array(image)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error convirtiendo archivo a imagen: {e}&quot;)&#10;            return None&#10;&#10;class PlateDetectionService:&#10;    &quot;&quot;&quot;Servicio para detección de placas usando EasyOCR&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.reader = easyocr.Reader(['en', 'es'])&#10;        self.plate_pattern = re.compile(r'^[A-Z]{3}-?\d{4}$|^\d{4}-?[A-Z]{3}$')&#10;        self.storage_service = SupabaseStorageService()&#10;        self.confidence_threshold = settings.AI_IMAGE_SETTINGS.get('PLATE_CONFIDENCE_THRESHOLD', 0.5)&#10;&#10;    def detect_plate(self, image_base64: str, camera_location: str = &quot;Estacionamiento&quot;,&#10;                     access_type: str = &quot;entrada&quot;) -&gt; Dict:&#10;        &quot;&quot;&quot;Detecta placa en la imagen&quot;&quot;&quot;&#10;        try:&#10;            image = self._base64_to_image(image_base64)&#10;            if image is None:&#10;                return self._create_detection_result(None, False, 0.0, image_base64,&#10;                                                     camera_location, access_type)&#10;&#10;            processed_image = self._preprocess_image(image)&#10;            results = self.reader.readtext(processed_image)&#10;&#10;            for (bbox, text, confidence) in results:&#10;                clean_text = self._clean_plate_text(text)&#10;&#10;                if self._is_valid_plate(clean_text) and confidence &gt; self.confidence_threshold:&#10;                    is_authorized = self._check_authorization(clean_text)&#10;&#10;                    return self._create_detection_result(&#10;                        clean_text, is_authorized, confidence * 100,&#10;                        image_base64, camera_location, access_type&#10;                    )&#10;&#10;            return self._create_detection_result(None, False, 0.0, image_base64,&#10;                                                 camera_location, access_type)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error en detección de placa: {e}&quot;)&#10;            return self._create_detection_result(None, False, 0.0, image_base64,&#10;                                                 camera_location, access_type)&#10;&#10;    def _preprocess_image(self, image: np.ndarray) -&gt; np.ndarray:&#10;        &quot;&quot;&quot;Preprocesa la imagen para mejor detección de placas&quot;&quot;&quot;&#10;        try:&#10;            gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)&#10;            blurred = cv2.GaussianBlur(gray, (5, 5), 0)&#10;            clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))&#10;            enhanced = clahe.apply(blurred)&#10;            return enhanced&#10;        except Exception as e:&#10;            logger.error(f&quot;Error preprocesando imagen: {e}&quot;)&#10;            return image&#10;&#10;    def _clean_plate_text(self, text: str) -&gt; str:&#10;        &quot;&quot;&quot;Limpia el texto detectado de la placa&quot;&quot;&quot;&#10;        cleaned = re.sub(r'[^A-Z0-9-]', '', text.upper())&#10;&#10;        if len(cleaned) == 7 and cleaned[3] != '-':&#10;            if cleaned[:3].isalpha() and cleaned[3:].isdigit():&#10;                cleaned = f&quot;{cleaned[:3]}-{cleaned[3:]}&quot;&#10;            elif cleaned[:4].isdigit() and cleaned[4:].isalpha():&#10;                cleaned = f&quot;{cleaned[:4]}-{cleaned[4:]}&quot;&#10;&#10;        return cleaned&#10;&#10;    def _is_valid_plate(self, text: str) -&gt; bool:&#10;        &quot;&quot;&quot;Verifica si el texto parece una placa válida&quot;&quot;&quot;&#10;        return bool(self.plate_pattern.match(text))&#10;&#10;    def _check_authorization(self, plate: str) -&gt; bool:&#10;        &quot;&quot;&quot;Verifica si la placa está autorizada&quot;&quot;&quot;&#10;        try:&#10;            vehiculo = Vehiculo.objects.filter(&#10;                nro_placa__iexact=plate,&#10;                estado='activo'&#10;            ).first()&#10;            return vehiculo is not None&#10;        except Exception as e:&#10;            logger.error(f&quot;Error verificando autorización de placa {plate}: {e}&quot;)&#10;            return False&#10;&#10;    def _create_detection_result(self, plate: Optional[str], is_authorized: bool,&#10;                                 confidence: float, image_base64: str, camera_location: str,&#10;                                 access_type: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Crea y guarda el resultado de la detección&quot;&quot;&quot;&#10;        try:&#10;            upload_result = self.storage_service.upload_base64_image(&#10;                image_base64,&#10;                folder=&quot;plates&quot;,&#10;                prefix=f&quot;{access_type}_{camera_location.lower().replace(' ', '_')}&quot;&#10;            )&#10;&#10;            vehiculo = None&#10;            if plate:&#10;                vehiculo = Vehiculo.objects.filter(nro_placa__iexact=plate).first()&#10;&#10;            deteccion = DeteccionPlaca.objects.create(&#10;                placa_detectada=plate or &quot;No detectada&quot;,&#10;                vehiculo=vehiculo,&#10;                imagen_path=upload_result['file_path'] if upload_result else None,&#10;                imagen_url=upload_result['public_url'] if upload_result else None,&#10;                confianza=confidence,&#10;                es_autorizado=is_authorized,&#10;                ubicacion_camara=camera_location,&#10;                tipo_acceso=access_type&#10;            )&#10;&#10;            return {&#10;                'id': deteccion.id,&#10;                'plate': plate,&#10;                'is_authorized': is_authorized,&#10;                'vehicle': {&#10;                    'id': vehiculo.id if vehiculo else None,&#10;                    'descripcion': vehiculo.descripcion if vehiculo else None,&#10;                    'estado': vehiculo.estado if vehiculo else None&#10;                } if vehiculo else None,&#10;                'confidence': round(confidence, 2),&#10;                'timestamp': deteccion.fecha_deteccion.isoformat(),&#10;                'camera_location': camera_location,&#10;                'access_type': access_type,&#10;                'status': 'autorizado' if is_authorized else 'no_autorizado',&#10;                'image_url': deteccion.imagen_url&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creando resultado de detección: {e}&quot;)&#10;            return {&#10;                'id': None,&#10;                'plate': plate,&#10;                'is_authorized': False,&#10;                'vehicle': None,&#10;                'confidence': 0.0,&#10;                'timestamp': None,&#10;                'camera_location': camera_location,&#10;                'access_type': access_type,&#10;                'status': 'error',&#10;                'image_url': None&#10;            }&#10;&#10;    def _base64_to_image(self, base64_string: str) -&gt; Optional[np.ndarray]:&#10;        &quot;&quot;&quot;Convierte base64 a imagen numpy&quot;&quot;&quot;&#10;        try:&#10;            if base64_string.startswith('data:image'):&#10;                base64_string = base64_string.split(',', 1)[1]&#10;&#10;            image_data = base64.b64decode(base64_string)&#10;            image = Image.open(io.BytesIO(image_data))&#10;&#10;            if image.mode != 'RGB':&#10;                image = image.convert('RGB')&#10;&#10;            return np.array(image)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error convirtiendo base64 a imagen: {e}&quot;)&#10;            return None&#10;" />
              <option name="updatedContent" value="# api/services/ai_detection.py&#10;import cv2&#10;import face_recognition&#10;import numpy as np&#10;import json&#10;import base64&#10;import io&#10;from PIL import Image&#10;import easyocr&#10;import re&#10;from typing import List, Tuple, Optional, Dict&#10;from django.conf import settings&#10;from ..models import Usuario, PerfilFacial, ReconocimientoFacial, DeteccionPlaca, Vehiculo&#10;from .supabase_storage import SupabaseStorageService&#10;import logging&#10;from django.core.files.uploadedfile import InMemoryUploadedFile&#10;import requests&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;class FacialRecognitionService:&#10;    &quot;&quot;&quot;Servicio para reconocimiento facial usando face_recognition&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.tolerance = settings.AI_IMAGE_SETTINGS.get('FACE_TOLERANCE', 0.6)&#10;        self.known_encodings = []&#10;        self.known_users = []&#10;        self.storage_service = SupabaseStorageService()&#10;        self.load_known_faces()&#10;&#10;    def load_known_faces(self):&#10;        &quot;&quot;&quot;Carga las caras conocidas desde la base de datos&quot;&quot;&quot;&#10;        try:&#10;            perfiles = PerfilFacial.objects.filter(activo=True).select_related('codigo_usuario')&#10;&#10;            self.known_encodings = []&#10;            self.known_users = []&#10;&#10;            for perfil in perfiles:&#10;                try:&#10;                    encoding = np.array(json.loads(perfil.encoding_facial))&#10;                    self.known_encodings.append(encoding)&#10;                    self.known_users.append(perfil.codigo_usuario)&#10;                except Exception as e:&#10;                    logger.error(f&quot;Error cargando perfil facial {perfil.id}: {e}&quot;)&#10;&#10;            logger.info(f&quot;Cargados {len(self.known_encodings)} perfiles faciales&quot;)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error cargando caras conocidas: {e}&quot;)&#10;&#10;    def register_face(self, user_id: int, image_base64: str) -&gt; bool:&#10;        &quot;&quot;&quot;Registra una nueva cara en el sistema&quot;&quot;&quot;&#10;        try:&#10;            image = self._base64_to_image(image_base64)&#10;            if image is None:&#10;                return False&#10;&#10;            face_locations = face_recognition.face_locations(image)&#10;            if not face_locations:&#10;                logger.warning(&quot;No se detectó ninguna cara en la imagen&quot;)&#10;                return False&#10;&#10;            face_encodings = face_recognition.face_encodings(image, face_locations)&#10;            if not face_encodings:&#10;                logger.warning(&quot;No se pudo generar encoding facial&quot;)&#10;                return False&#10;&#10;            encoding = face_encodings[0]&#10;&#10;            upload_result = self.storage_service.upload_base64_image(&#10;                image_base64,&#10;                folder=&quot;profiles&quot;,&#10;                prefix=f&quot;user_{user_id}&quot;&#10;            )&#10;&#10;            if not upload_result:&#10;                logger.error(&quot;Error subiendo imagen a Supabase&quot;)&#10;                return False&#10;&#10;            usuario = Usuario.objects.get(codigo=user_id)&#10;            perfil, created = PerfilFacial.objects.get_or_create(&#10;                codigo_usuario=usuario,&#10;                defaults={&#10;                    'encoding_facial': json.dumps(encoding.tolist()),&#10;                    'imagen_path': upload_result['file_path'],&#10;                    'imagen_url': upload_result['public_url'],&#10;                    'activo': True&#10;                }&#10;            )&#10;&#10;            if not created:&#10;                if perfil.imagen_path:&#10;                    self.storage_service.delete_file(perfil.imagen_path)&#10;&#10;                perfil.encoding_facial = json.dumps(encoding.tolist())&#10;                perfil.imagen_path = upload_result['file_path']&#10;                perfil.imagen_url = upload_result['public_url']&#10;                perfil.activo = True&#10;                perfil.save()&#10;&#10;            self.load_known_faces()&#10;&#10;            logger.info(f&quot;Cara registrada para usuario {user_id}&quot;)&#10;            return True&#10;&#10;        except Usuario.DoesNotExist:&#10;            logger.error(f&quot;Usuario {user_id} no existe&quot;)&#10;            return False&#10;        except Exception as e:&#10;            logger.error(f&quot;Error registrando cara: {e}&quot;)&#10;            return False&#10;&#10;    def recognize_face(self, image_base64: str, camera_location: str = &quot;Principal&quot;) -&gt; Dict:&#10;        &quot;&quot;&quot;Reconoce una cara en la imagen usando el microservicio de IA&quot;&quot;&quot;&#10;        try:&#10;            # Serializar encodings y usuarios conocidos&#10;            known_encodings = [enc.tolist() for enc in self.known_encodings]&#10;            known_users = [str(u.codigo) for u in self.known_users]&#10;            payload = {&#10;                &quot;image_base64&quot;: image_base64,&#10;                &quot;known_encodings&quot;: known_encodings,&#10;                &quot;known_users&quot;: known_users,&#10;                &quot;tolerance&quot;: self.tolerance&#10;            }&#10;            # Llamar al microservicio&#10;            url = settings.AI_MICROSERVICE_URL + &quot;/recognize-face/&quot;&#10;            resp = requests.post(url, json=payload, timeout=10)&#10;            resp.raise_for_status()&#10;            data = resp.json()&#10;            # Procesar respuesta&#10;            results = data.get(&quot;results&quot;, [])&#10;            for result in results:&#10;                user_codigo = result.get(&quot;user&quot;)&#10;                if user_codigo:&#10;                    usuario = Usuario.objects.filter(codigo=user_codigo).first()&#10;                    confidence = 100.0  # El microservicio no calcula confianza, puedes ajustar si lo deseas&#10;                    return self._create_recognition_result(&#10;                        True, usuario, confidence, image_base64, camera_location&#10;                    )&#10;            return self._create_recognition_result(False, None, 0.0, image_base64, camera_location)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error en reconocimiento facial (microservicio): {e}&quot;)&#10;            return self._create_recognition_result(False, None, 0.0, image_base64, camera_location)&#10;&#10;    def _create_recognition_result(self, is_resident: bool, usuario: Optional[Usuario],&#10;                                   confidence: float, image_base64: str, camera_location: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Crea y guarda el resultado del reconocimiento&quot;&quot;&quot;&#10;        try:&#10;            upload_result = self.storage_service.upload_base64_image(&#10;                image_base64,&#10;                folder=&quot;facial&quot;,&#10;                prefix=f&quot;detection_{camera_location.lower().replace(' ', '_')}&quot;&#10;            )&#10;&#10;            reconocimiento = ReconocimientoFacial.objects.create(&#10;                codigo_usuario=usuario,&#10;                imagen_path=upload_result['file_path'] if upload_result else None,&#10;                imagen_url=upload_result['public_url'] if upload_result else None,&#10;                confianza=confidence,&#10;                es_residente=is_resident,&#10;                ubicacion_camara=camera_location,&#10;                estado='permitido' if is_resident else 'denegado'&#10;            )&#10;&#10;            return {&#10;                'id': reconocimiento.id,&#10;                'is_resident': is_resident,&#10;                'user': {&#10;                    'codigo': usuario.codigo if usuario else None,&#10;                    'nombre': f&quot;{usuario.nombre} {usuario.apellido}&quot; if usuario else &quot;Desconocido&quot;,&#10;                    'correo': usuario.correo if usuario else None&#10;                } if usuario else None,&#10;                'confidence': round(confidence, 2),&#10;                'timestamp': reconocimiento.fecha_deteccion.isoformat(),&#10;                'camera_location': camera_location,&#10;                'status': 'permitido' if is_resident else 'denegado',&#10;                'image_url': reconocimiento.imagen_url&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creando resultado de reconocimiento: {e}&quot;)&#10;            return {&#10;                'id': None,&#10;                'is_resident': False,&#10;                'user': None,&#10;                'confidence': 0.0,&#10;                'timestamp': None,&#10;                'camera_location': camera_location,&#10;                'status': 'error',&#10;                'image_url': None&#10;            }&#10;&#10;    def _base64_to_image(self, base64_string: str) -&gt; Optional[np.ndarray]:&#10;        &quot;&quot;&quot;Convierte base64 a imagen numpy&quot;&quot;&quot;&#10;        try:&#10;            if base64_string.startswith('data:image'):&#10;                base64_string = base64_string.split(',', 1)[1]&#10;&#10;            image_data = base64.b64decode(base64_string)&#10;            image = Image.open(io.BytesIO(image_data))&#10;&#10;            if image.mode != 'RGB':&#10;                image = image.convert('RGB')&#10;&#10;            return np.array(image)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error convirtiendo base64 a imagen: {e}&quot;)&#10;            return None&#10;    def register_face_from_file(self, user_id: int, image_file: InMemoryUploadedFile) -&gt; bool:&#10;        &quot;&quot;&quot;Registra una nueva cara desde un archivo Django&quot;&quot;&quot;&#10;        try:&#10;            # Convertir archivo Django a imagen numpy&#10;            image = self._file_to_image(image_file)&#10;            if image is None:&#10;                return False&#10;&#10;            face_locations = face_recognition.face_locations(image)&#10;            if not face_locations:&#10;                logger.warning(&quot;No se detectó ninguna cara en la imagen&quot;)&#10;                return False&#10;&#10;            face_encodings = face_recognition.face_encodings(image, face_locations)&#10;            if not face_encodings:&#10;                logger.warning(&quot;No se pudo generar encoding facial&quot;)&#10;                return False&#10;&#10;            encoding = face_encodings[0]&#10;&#10;            # Subir archivo directamente a Supabase&#10;            upload_result = self.storage_service.upload_django_file(&#10;                image_file,&#10;                folder=&quot;profiles&quot;,&#10;                prefix=f&quot;user_{user_id}&quot;&#10;            )&#10;&#10;            if not upload_result:&#10;                logger.error(&quot;Error subiendo imagen a Supabase&quot;)&#10;                return False&#10;&#10;            usuario = Usuario.objects.get(codigo=user_id)&#10;            perfil, created = PerfilFacial.objects.get_or_create(&#10;                codigo_usuario=usuario,&#10;                defaults={&#10;                    'encoding_facial': json.dumps(encoding.tolist()),&#10;                    'imagen_path': upload_result['file_path'],&#10;                    'imagen_url': upload_result['public_url'],&#10;                    'activo': True&#10;                }&#10;            )&#10;&#10;            if not created:&#10;                if perfil.imagen_path:&#10;                    self.storage_service.delete_file(perfil.imagen_path)&#10;&#10;                perfil.encoding_facial = json.dumps(encoding.tolist())&#10;                perfil.imagen_path = upload_result['file_path']&#10;                perfil.imagen_url = upload_result['public_url']&#10;                perfil.activo = True&#10;                perfil.save()&#10;&#10;            self.load_known_faces()&#10;&#10;            logger.info(f&quot;Cara registrada para usuario {user_id}&quot;)&#10;            return True&#10;&#10;        except Usuario.DoesNotExist:&#10;            logger.error(f&quot;Usuario {user_id} no existe&quot;)&#10;            return False&#10;        except Exception as e:&#10;            logger.error(f&quot;Error registrando cara desde archivo: {e}&quot;)&#10;            return False&#10;&#10;    def recognize_face_from_file(self, image_file: InMemoryUploadedFile, camera_location: str = &quot;Principal&quot;) -&gt; Dict:&#10;        &quot;&quot;&quot;Reconoce una cara desde un archivo Django&quot;&quot;&quot;&#10;        try:&#10;            image = self._file_to_image(image_file)&#10;            if image is None:&#10;                return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;            face_locations = face_recognition.face_locations(image)&#10;            if not face_locations:&#10;                return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;            face_encodings = face_recognition.face_encodings(image, face_locations)&#10;            if not face_encodings:&#10;                return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;            for face_encoding in face_encodings:&#10;                if not self.known_encodings:&#10;                    break&#10;&#10;                matches = face_recognition.compare_faces(&#10;                    self.known_encodings, face_encoding, tolerance=self.tolerance&#10;                )&#10;                face_distances = face_recognition.face_distance(&#10;                    self.known_encodings, face_encoding&#10;                )&#10;&#10;                if any(matches):&#10;                    best_match_index = np.argmin(face_distances)&#10;                    if matches[best_match_index]:&#10;                        usuario = self.known_users[best_match_index]&#10;                        confidence = (1 - face_distances[best_match_index]) * 100&#10;&#10;                        return self._create_recognition_result_from_file(&#10;                            True, usuario, confidence, image_file, camera_location&#10;                        )&#10;&#10;            return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error en reconocimiento facial desde archivo: {e}&quot;)&#10;            return self._create_recognition_result_from_file(False, None, 0.0, image_file, camera_location)&#10;&#10;    def _create_recognition_result_from_file(self, is_resident: bool, usuario: Optional[Usuario],&#10;                                           confidence: float, image_file: InMemoryUploadedFile, camera_location: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Crea y guarda el resultado del reconocimiento desde archivo&quot;&quot;&quot;&#10;        try:&#10;            upload_result = self.storage_service.upload_django_file(&#10;                image_file,&#10;                folder=&quot;facial&quot;,&#10;                prefix=f&quot;detection_{camera_location.lower().replace(' ', '_')}&quot;&#10;            )&#10;&#10;            reconocimiento = ReconocimientoFacial.objects.create(&#10;                codigo_usuario=usuario,&#10;                imagen_path=upload_result['file_path'] if upload_result else None,&#10;                imagen_url=upload_result['public_url'] if upload_result else None,&#10;                confianza=confidence,&#10;                es_residente=is_resident,&#10;                ubicacion_camara=camera_location,&#10;                estado='permitido' if is_resident else 'denegado'&#10;            )&#10;&#10;            return {&#10;                'id': reconocimiento.id,&#10;                'is_resident': is_resident,&#10;                'user': {&#10;                    'codigo': usuario.codigo if usuario else None,&#10;                    'nombre': f&quot;{usuario.nombre} {usuario.apellido}&quot; if usuario else &quot;Desconocido&quot;,&#10;                    'correo': usuario.correo if usuario else None&#10;                } if usuario else None,&#10;                'confidence': round(confidence, 2),&#10;                'timestamp': reconocimiento.fecha_deteccion.isoformat(),&#10;                'camera_location': camera_location,&#10;                'status': 'permitido' if is_resident else 'denegado',&#10;                'image_url': reconocimiento.imagen_url&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creando resultado de reconocimiento desde archivo: {e}&quot;)&#10;            return {&#10;                'id': None,&#10;                'is_resident': False,&#10;                'user': None,&#10;                'confidence': 0.0,&#10;                'timestamp': None,&#10;                'camera_location': camera_location,&#10;                'status': 'error',&#10;                'image_url': None&#10;            }&#10;&#10;    def _file_to_image(self, image_file: InMemoryUploadedFile) -&gt; Optional[np.ndarray]:&#10;        &quot;&quot;&quot;Convierte archivo Django a imagen numpy&quot;&quot;&quot;&#10;        try:&#10;            image_file.seek(0)  # Asegurar que estamos al inicio del archivo&#10;            image_data = image_file.read()&#10;            image = Image.open(io.BytesIO(image_data))&#10;&#10;            if image.mode != 'RGB':&#10;                image = image.convert('RGB')&#10;&#10;            return np.array(image)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error convirtiendo archivo a imagen: {e}&quot;)&#10;            return None&#10;&#10;# En la clase PlateDetectionService, agregar estos métodos:&#10;&#10;    def detect_plate_from_file(self, image_file: InMemoryUploadedFile, camera_location: str = &quot;Estacionamiento&quot;,&#10;                              access_type: str = &quot;entrada&quot;) -&gt; Dict:&#10;        &quot;&quot;&quot;Detecta placa desde un archivo Django&quot;&quot;&quot;&#10;        try:&#10;            image = self._file_to_image(image_file)&#10;            if image is None:&#10;                return self._create_detection_result_from_file(None, False, 0.0, image_file,&#10;                                                             camera_location, access_type)&#10;&#10;            processed_image = self._preprocess_image(image)&#10;            results = self.reader.readtext(processed_image)&#10;&#10;            for (bbox, text, confidence) in results:&#10;                clean_text = self._clean_plate_text(text)&#10;&#10;                if self._is_valid_plate(clean_text) and confidence &gt; self.confidence_threshold:&#10;                    is_authorized = self._check_authorization(clean_text)&#10;&#10;                    return self._create_detection_result_from_file(&#10;                        clean_text, is_authorized, confidence * 100,&#10;                        image_file, camera_location, access_type&#10;                    )&#10;&#10;            return self._create_detection_result_from_file(None, False, 0.0, image_file,&#10;                                                         camera_location, access_type)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error en detección de placa desde archivo: {e}&quot;)&#10;            return self._create_detection_result_from_file(None, False, 0.0, image_file,&#10;                                                         camera_location, access_type)&#10;&#10;    def _create_detection_result_from_file(self, plate: Optional[str], is_authorized: bool,&#10;                                         confidence: float, image_file: InMemoryUploadedFile, camera_location: str,&#10;                                         access_type: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Crea y guarda el resultado de la detección desde archivo&quot;&quot;&quot;&#10;        try:&#10;            upload_result = self.storage_service.upload_django_file(&#10;                image_file,&#10;                folder=&quot;plates&quot;,&#10;                prefix=f&quot;{access_type}_{camera_location.lower().replace(' ', '_')}&quot;&#10;            )&#10;&#10;            vehiculo = None&#10;            if plate:&#10;                vehiculo = Vehiculo.objects.filter(nro_placa__iexact=plate).first()&#10;&#10;            deteccion = DeteccionPlaca.objects.create(&#10;                placa_detectada=plate or &quot;No detectada&quot;,&#10;                vehiculo=vehiculo,&#10;                imagen_path=upload_result['file_path'] if upload_result else None,&#10;                imagen_url=upload_result['public_url'] if upload_result else None,&#10;                confianza=confidence,&#10;                es_autorizado=is_authorized,&#10;                ubicacion_camara=camera_location,&#10;                tipo_acceso=access_type&#10;            )&#10;&#10;            return {&#10;                'id': deteccion.id,&#10;                'plate': plate,&#10;                'is_authorized': is_authorized,&#10;                'vehicle': {&#10;                    'id': vehiculo.id if vehiculo else None,&#10;                    'descripcion': vehiculo.descripcion if vehiculo else None,&#10;                    'estado': vehiculo.estado if vehiculo else None&#10;                } if vehiculo else None,&#10;                'confidence': round(confidence, 2),&#10;                'timestamp': deteccion.fecha_deteccion.isoformat(),&#10;                'camera_location': camera_location,&#10;                'access_type': access_type,&#10;                'status': 'autorizado' if is_authorized else 'no_autorizado',&#10;                'image_url': deteccion.imagen_url&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creando resultado de detección desde archivo: {e}&quot;)&#10;            return {&#10;                'id': None,&#10;                'plate': plate,&#10;                'is_authorized': False,&#10;                'vehicle': None,&#10;                'confidence': 0.0,&#10;                'timestamp': None,&#10;                'camera_location': camera_location,&#10;                'access_type': access_type,&#10;                'status': 'error',&#10;                'image_url': None&#10;            }&#10;&#10;    def _file_to_image(self, image_file: InMemoryUploadedFile) -&gt; Optional[np.ndarray]:&#10;        &quot;&quot;&quot;Convierte archivo Django a imagen numpy&quot;&quot;&quot;&#10;        try:&#10;            image_file.seek(0)&#10;            image_data = image_file.read()&#10;            image = Image.open(io.BytesIO(image_data))&#10;&#10;            if image.mode != 'RGB':&#10;                image = image.convert('RGB')&#10;&#10;            return np.array(image)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error convirtiendo archivo a imagen: {e}&quot;)&#10;            return None&#10;&#10;class PlateDetectionService:&#10;    &quot;&quot;&quot;Servicio para detección de placas usando EasyOCR&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.reader = easyocr.Reader(['en', 'es'])&#10;        self.plate_pattern = re.compile(r'^[A-Z]{3}-?\d{4}$|^\d{4}-?[A-Z]{3}$')&#10;        self.storage_service = SupabaseStorageService()&#10;        self.confidence_threshold = settings.AI_IMAGE_SETTINGS.get('PLATE_CONFIDENCE_THRESHOLD', 0.5)&#10;&#10;    def detect_plate(self, image_base64: str, camera_location: str = &quot;Estacionamiento&quot;,&#10;                     access_type: str = &quot;entrada&quot;) -&gt; Dict:&#10;        &quot;&quot;&quot;Detecta placa en la imagen usando el microservicio de IA&quot;&quot;&quot;&#10;        try:&#10;            payload = {&quot;image_base64&quot;: image_base64}&#10;            url = settings.AI_MICROSERVICE_URL + &quot;/detect-plate/&quot;&#10;            resp = requests.post(url, json=payload, timeout=20)&#10;            resp.raise_for_status()&#10;            data = resp.json()&#10;            plates = data.get(&quot;plates&quot;, [])&#10;            # Buscar la placa con mayor confianza&#10;            best_plate = None&#10;            best_conf = 0.0&#10;            for plate_info in plates:&#10;                if plate_info[&quot;confidence&quot;] &gt; best_conf:&#10;                    best_plate = plate_info[&quot;plate&quot;]&#10;                    best_conf = plate_info[&quot;confidence&quot;]&#10;            if best_plate:&#10;                is_authorized = self._check_authorization(best_plate)&#10;                return self._create_detection_result(&#10;                    best_plate, is_authorized, best_conf * 100,&#10;                    image_base64, camera_location, access_type&#10;                )&#10;            return self._create_detection_result(None, False, 0.0, image_base64, camera_location, access_type)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error en detección de placa (microservicio): {e}&quot;)&#10;            return self._create_detection_result(None, False, 0.0, image_base64, camera_location, access_type)&#10;&#10;    def _preprocess_image(self, image: np.ndarray) -&gt; np.ndarray:&#10;        &quot;&quot;&quot;Preprocesa la imagen para mejor detección de placas&quot;&quot;&quot;&#10;        try:&#10;            gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)&#10;            blurred = cv2.GaussianBlur(gray, (5, 5), 0)&#10;            clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))&#10;            enhanced = clahe.apply(blurred)&#10;            return enhanced&#10;        except Exception as e:&#10;            logger.error(f&quot;Error preprocesando imagen: {e}&quot;)&#10;            return image&#10;&#10;    def _clean_plate_text(self, text: str) -&gt; str:&#10;        &quot;&quot;&quot;Limpia el texto detectado de la placa&quot;&quot;&quot;&#10;        cleaned = re.sub(r'[^A-Z0-9-]', '', text.upper())&#10;&#10;        if len(cleaned) == 7 and cleaned[3] != '-':&#10;            if cleaned[:3].isalpha() and cleaned[3:].isdigit():&#10;                cleaned = f&quot;{cleaned[:3]}-{cleaned[3:]}&quot;&#10;            elif cleaned[:4].isdigit() and cleaned[4:].isalpha():&#10;                cleaned = f&quot;{cleaned[:4]}-{cleaned[4:]}&quot;&#10;&#10;        return cleaned&#10;&#10;    def _is_valid_plate(self, text: str) -&gt; bool:&#10;        &quot;&quot;&quot;Verifica si el texto parece una placa válida&quot;&quot;&quot;&#10;        return bool(self.plate_pattern.match(text))&#10;&#10;    def _check_authorization(self, plate: str) -&gt; bool:&#10;        &quot;&quot;&quot;Verifica si la placa está autorizada&quot;&quot;&quot;&#10;        try:&#10;            vehiculo = Vehiculo.objects.filter(&#10;                nro_placa__iexact=plate,&#10;                estado='activo'&#10;            ).first()&#10;            return vehiculo is not None&#10;        except Exception as e:&#10;            logger.error(f&quot;Error verificando autorización de placa {plate}: {e}&quot;)&#10;            return False&#10;&#10;    def _create_detection_result(self, plate: Optional[str], is_authorized: bool,&#10;                                 confidence: float, image_base64: str, camera_location: str,&#10;                                 access_type: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Crea y guarda el resultado de la detección&quot;&quot;&quot;&#10;        try:&#10;            upload_result = self.storage_service.upload_base64_image(&#10;                image_base64,&#10;                folder=&quot;plates&quot;,&#10;                prefix=f&quot;{access_type}_{camera_location.lower().replace(' ', '_')}&quot;&#10;            )&#10;&#10;            vehiculo = None&#10;            if plate:&#10;                vehiculo = Vehiculo.objects.filter(nro_placa__iexact=plate).first()&#10;&#10;            deteccion = DeteccionPlaca.objects.create(&#10;                placa_detectada=plate or &quot;No detectada&quot;,&#10;                vehiculo=vehiculo,&#10;                imagen_path=upload_result['file_path'] if upload_result else None,&#10;                imagen_url=upload_result['public_url'] if upload_result else None,&#10;                confianza=confidence,&#10;                es_autorizado=is_authorized,&#10;                ubicacion_camara=camera_location,&#10;                tipo_acceso=access_type&#10;            )&#10;&#10;            return {&#10;                'id': deteccion.id,&#10;                'plate': plate,&#10;                'is_authorized': is_authorized,&#10;                'vehicle': {&#10;                    'id': vehiculo.id if vehiculo else None,&#10;                    'descripcion': vehiculo.descripcion if vehiculo else None,&#10;                    'estado': vehiculo.estado if vehiculo else None&#10;                } if vehiculo else None,&#10;                'confidence': round(confidence, 2),&#10;                'timestamp': deteccion.fecha_deteccion.isoformat(),&#10;                'camera_location': camera_location,&#10;                'access_type': access_type,&#10;                'status': 'autorizado' if is_authorized else 'no_autorizado',&#10;                'image_url': deteccion.imagen_url&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error creando resultado de detección: {e}&quot;)&#10;            return {&#10;                'id': None,&#10;                'plate': plate,&#10;                'is_authorized': False,&#10;                'vehicle': None,&#10;                'confidence': 0.0,&#10;                'timestamp': None,&#10;                'camera_location': camera_location,&#10;                'access_type': access_type,&#10;                'status': 'error',&#10;                'image_url': None&#10;            }&#10;&#10;    def _base64_to_image(self, base64_string: str) -&gt; Optional[np.ndarray]:&#10;        &quot;&quot;&quot;Convierte base64 a imagen numpy&quot;&quot;&quot;&#10;        try:&#10;            if base64_string.startswith('data:image'):&#10;                base64_string = base64_string.split(',', 1)[1]&#10;&#10;            image_data = base64.b64decode(base64_string)&#10;            image = Image.open(io.BytesIO(image_data))&#10;&#10;            if image.mode != 'RGB':&#10;                image = image.convert('RGB')&#10;&#10;            return np.array(image)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error convirtiendo base64 a imagen: {e}&quot;)&#10;            return None&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/settings.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/settings.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Django settings for backend project.&#10;&quot;&quot;&quot;&#10;&#10;from pathlib import Path&#10;import os&#10;from dotenv import load_dotenv&#10;import dj_database_url&#10;&#10;# ------------------------------------&#10;# Paths / .env&#10;# ------------------------------------&#10;BASE_DIR = Path(__file__).resolve().parent.parent&#10;load_dotenv(BASE_DIR / &quot;.env&quot;)&#10;&#10;# ------------------------------------&#10;# Seguridad / Debug&#10;# ------------------------------------&#10;SECRET_KEY = os.getenv(&quot;SECRET_KEY&quot;, &quot;dev-only-not-secret&quot;)&#10;DEBUG = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;&#10;def _csv_env(name: str, default: list[str]) -&gt; list[str]:&#10;    raw = os.getenv(name, &quot;&quot;)&#10;    if not raw:&#10;        return default&#10;    return [x.strip() for x in raw.split(&quot;,&quot;) if x.strip()]&#10;&#10;if DEBUG:&#10;    # Desarrollo: abierto y cómodo&#10;    CORS_ALLOW_ALL_ORIGINS = True&#10;    CORS_ALLOW_CREDENTIALS = True&#10;    ALLOWED_HOSTS = [&quot;*&quot;]&#10;    SESSION_COOKIE_SAMESITE = &quot;Lax&quot;&#10;    CSRF_COOKIE_SAMESITE = &quot;Lax&quot;&#10;    SESSION_COOKIE_SECURE = False&#10;    CSRF_COOKIE_SECURE = False&#10;else:&#10;    # Producción: más estricto&#10;    CORS_ALLOW_ALL_ORIGINS = False&#10;    CORS_ALLOWED_ORIGINS = _csv_env(&#10;        &quot;CORS_ALLOWED_ORIGINS&quot;,&#10;        [&quot;https://tu-frontend.com&quot;]&#10;    )&#10;    CORS_ALLOW_CREDENTIALS = True&#10;    ALLOWED_HOSTS = _csv_env(&quot;ALLOWED_HOSTS&quot;, [&quot;127.0.0.1&quot;, &quot;localhost&quot;])&#10;    SESSION_COOKIE_SAMESITE = os.getenv(&quot;SESSION_COOKIE_SAMESITE&quot;, &quot;None&quot;)&#10;    CSRF_COOKIE_SAMESITE = os.getenv(&quot;CSRF_COOKIE_SAMESITE&quot;, &quot;None&quot;)&#10;    SESSION_COOKIE_SECURE = True&#10;    CSRF_COOKIE_SECURE = True&#10;&#10;CSRF_TRUSTED_ORIGINS = _csv_env(&#10;    &quot;CSRF_TRUSTED_ORIGINS&quot;,&#10;    [&#10;        &quot;http://127.0.0.1:8000&quot;,&#10;        &quot;http://localhost:8000&quot;,&#10;        &quot;http://127.0.0.1:5173&quot;,&#10;        &quot;http://localhost:5173&quot;,&#10;        &quot;http://127.0.0.1:3000&quot;,&#10;        &quot;http://localhost:3000&quot;,&#10;    ]&#10;)&#10;&#10;CSRF_COOKIE_NAME = &quot;csrftoken&quot;&#10;SECURE_PROXY_SSL_HEADER = (&quot;HTTP_X_FORWARDED_PROTO&quot;, &quot;https&quot;)&#10;SECURE_HSTS_SECONDS = 0 if DEBUG else 60 * 60 * 24 * 30  # 30 días&#10;SECURE_SSL_REDIRECT = not DEBUG&#10;&#10;# ------------------------------------&#10;# Apps&#10;# ------------------------------------&#10;INSTALLED_APPS = [&#10;    &quot;corsheaders&quot;,&#10;    &quot;django.contrib.admin&quot;,&#10;    &quot;django.contrib.auth&quot;,&#10;    &quot;django.contrib.contenttypes&quot;,&#10;    &quot;django.contrib.sessions&quot;,&#10;    &quot;django.contrib.messages&quot;,&#10;    &quot;django.contrib.staticfiles&quot;,&#10;    &quot;rest_framework&quot;,&#10;    &quot;rest_framework.authtoken&quot;,&#10;    &quot;django_filters&quot;,&#10;&#10;    &quot;api&quot;,  # tu app&#10;]&#10;&#10;# ------------------------------------&#10;# Middleware&#10;# ------------------------------------&#10;MIDDLEWARE = [&#10;    &quot;django.middleware.security.SecurityMiddleware&quot;,&#10;    &quot;whitenoise.middleware.WhiteNoiseMiddleware&quot;,&#10;    &quot;corsheaders.middleware.CorsMiddleware&quot;,&#10;    &quot;django.contrib.sessions.middleware.SessionMiddleware&quot;,&#10;    &quot;django.middleware.common.CommonMiddleware&quot;,&#10;    &quot;django.middleware.csrf.CsrfViewMiddleware&quot;,&#10;    &quot;django.contrib.auth.middleware.AuthenticationMiddleware&quot;,&#10;    &quot;django.contrib.messages.middleware.MessageMiddleware&quot;,&#10;    &quot;django.middleware.clickjacking.XFrameOptionsMiddleware&quot;,&#10;]&#10;&#10;ROOT_URLCONF = &quot;backend.urls&quot;&#10;&#10;TEMPLATES = [&#10;    {&#10;        &quot;BACKEND&quot;: &quot;django.template.backends.django.DjangoTemplates&quot;,&#10;        &quot;DIRS&quot;: [BASE_DIR / &quot;templates&quot;],&#10;        &quot;APP_DIRS&quot;: True,&#10;        &quot;OPTIONS&quot;: {&#10;            &quot;context_processors&quot;: [&#10;                &quot;django.template.context_processors.request&quot;,&#10;                &quot;django.contrib.auth.context_processors.auth&quot;,&#10;                &quot;django.contrib.messages.context_processors.messages&quot;,&#10;            ],&#10;        },&#10;    },&#10;]&#10;&#10;WSGI_APPLICATION = &quot;backend.wsgi.application&quot;&#10;&#10;# ------------------------------------&#10;DATABASES = {&#10;    &quot;default&quot;: dj_database_url.config(&#10;        env=&quot;DATABASE_URL&quot;,&#10;    )&#10;}&#10;&#10;# Configuraciones adicionales después&#10;_db_url = os.getenv(&quot;DATABASE_URL&quot;, &quot;&quot;)&#10;if &quot;:6543/&quot; in _db_url:&#10;    DATABASES[&quot;default&quot;][&quot;CONN_MAX_AGE&quot;] = 0&#10;else:&#10;    DATABASES[&quot;default&quot;][&quot;CONN_MAX_AGE&quot;] = 600&#10;&#10;# SSL para Supabase&#10;if &quot;supabase&quot; in _db_url:&#10;    DATABASES[&quot;default&quot;][&quot;OPTIONS&quot;] = {&#10;        &quot;sslmode&quot;: &quot;require&quot;&#10;    }&#10;# ------------------------------------&#10;# Password validators&#10;# ------------------------------------&#10;AUTH_PASSWORD_VALIDATORS = [&#10;    {&quot;NAME&quot;: &quot;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&quot;},&#10;    {&quot;NAME&quot;: &quot;django.contrib.auth.password_validation.MinimumLengthValidator&quot;, &quot;OPTIONS&quot;: {&quot;min_length&quot;: 8}},&#10;    {&quot;NAME&quot;: &quot;django.contrib.auth.password_validation.CommonPasswordValidator&quot;},&#10;    {&quot;NAME&quot;: &quot;django.contrib.auth.password_validation.NumericPasswordValidator&quot;},&#10;]&#10;&#10;# ------------------------------------&#10;# Localización&#10;# ------------------------------------&#10;LANGUAGE_CODE = &quot;es&quot;&#10;TIME_ZONE = &quot;America/La_Paz&quot;&#10;USE_I18N = True&#10;USE_TZ = True&#10;&#10;# ------------------------------------&#10;# Archivos estáticos (WhiteNoise)&#10;# ------------------------------------&#10;STATIC_URL = &quot;/static/&quot;&#10;STATIC_ROOT = BASE_DIR / &quot;staticfiles&quot;&#10;STATICFILES_STORAGE = &quot;whitenoise.storage.CompressedManifestStaticFilesStorage&quot;&#10;&#10;# ------------------------------------&#10;# DRF&#10;# ------------------------------------&#10;REST_FRAMEWORK = {&#10;    &quot;DEFAULT_PERMISSION_CLASSES&quot;: [&#10;        &quot;rest_framework.permissions.IsAuthenticated&quot;,&#10;    ],&#10;    &quot;DEFAULT_AUTHENTICATION_CLASSES&quot;: [&#10;        &quot;rest_framework.authentication.TokenAuthentication&quot;,&#10;        &quot;rest_framework.authentication.SessionAuthentication&quot;,&#10;    ],&#10;    &quot;DEFAULT_PAGINATION_CLASS&quot;: &quot;rest_framework.pagination.PageNumberPagination&quot;,&#10;    &quot;PAGE_SIZE&quot;: 25,&#10;    &quot;DEFAULT_FILTER_BACKENDS&quot;: [&#10;        &quot;django_filters.rest_framework.DjangoFilterBackend&quot;,&#10;        &quot;rest_framework.filters.SearchFilter&quot;,&#10;        &quot;rest_framework.filters.OrderingFilter&quot;,&#10;&#10;    ],&#10;&#10;}&#10;&#10;# ------------------------------------&#10;# Otros&#10;# ------------------------------------&#10;DEFAULT_AUTO_FIELD = &quot;django.db.models.BigAutoField&quot;&#10;&#10;# ------------------------------------&#10;# Frontend / Email (opcional)&#10;# ------------------------------------&#10;FRONTEND_URL = os.getenv(&quot;FRONTEND_URL&quot;, &quot;http://localhost:5173&quot;)&#10;DEFAULT_FROM_EMAIL = os.getenv(&quot;DEFAULT_FROM_EMAIL&quot;, &quot;no-reply@smart-condominium.local&quot;)&#10;&#10;EMAIL_BACKEND = os.getenv(&quot;EMAIL_BACKEND&quot;, &quot;django.core.mail.backends.smtp.EmailBackend&quot;)&#10;EMAIL_HOST = os.getenv(&quot;EMAIL_HOST&quot;, &quot;smtp.gmail.com&quot;)&#10;EMAIL_PORT = int(os.getenv(&quot;EMAIL_PORT&quot;, &quot;587&quot;))&#10;EMAIL_HOST_USER = os.getenv(&quot;EMAIL_HOST_USER&quot;, &quot;&quot;)&#10;EMAIL_HOST_PASSWORD = os.getenv(&quot;EMAIL_HOST_PASSWORD&quot;, &quot;&quot;)&#10;EMAIL_USE_TLS = os.getenv(&quot;EMAIL_USE_TLS&quot;, &quot;True&quot;) == &quot;True&quot;&#10;EMAIL_USE_SSL = os.getenv(&quot;EMAIL_USE_SSL&quot;, &quot;False&quot;) == &quot;True&quot;&#10;&#10;# ------------------------------------&#10;# Logging sencillo&#10;# ------------------------------------&#10;LOGGING = {&#10;    &quot;version&quot;: 1,&#10;    &quot;disable_existing_loggers&quot;: False,&#10;    &quot;formatters&quot;: {&#10;        &quot;verbose&quot;: {&quot;format&quot;: &quot;{levelname} {asctime} {module} {message}&quot;, &quot;style&quot;: &quot;{&quot;},&#10;    },&#10;    &quot;handlers&quot;: {&#10;        &quot;console&quot;: {&quot;class&quot;: &quot;logging.StreamHandler&quot;, &quot;formatter&quot;: &quot;verbose&quot;},&#10;    },&#10;    &quot;root&quot;: {&quot;handlers&quot;: [&quot;console&quot;], &quot;level&quot;: &quot;INFO&quot;},&#10;    &quot;loggers&quot;: {&#10;        &quot;django&quot;: {&quot;handlers&quot;: [&quot;console&quot;], &quot;level&quot;: &quot;INFO&quot;, &quot;propagate&quot;: False},&#10;        &quot;api&quot;: {&quot;handlers&quot;: [&quot;console&quot;], &quot;level&quot;: &quot;DEBUG&quot;, &quot;propagate&quot;: False},&#10;    },&#10;}&#10;&#10;SUPABASE_URL = os.getenv(&quot;SUPABASE_URL&quot;)&#10;SUPABASE_SERVICE_KEY = os.getenv(&quot;SUPABASE_SERVICE_ROLE_KEY&quot;)&#10;SUPABASE_STORAGE_BUCKET = os.getenv(&quot;SUPABASE_STORAGE_BUCKET&quot;, &quot;ai-detection-images&quot;)&#10;SUPABASE_STORAGE_URL = f&quot;{SUPABASE_URL}/storage/v1/object/public/{SUPABASE_STORAGE_BUCKET}&quot;&#10;&#10;# ------------------------------------&#10;# Configuración de IA&#10;# ------------------------------------&#10;AI_IMAGE_SETTINGS = {&#10;    'MAX_SIZE': (1920, 1080),&#10;    'THUMBNAIL_SIZE': (800, 600),&#10;    'JPEG_QUALITY': int(os.getenv(&quot;AI_JPEG_QUALITY&quot;, &quot;85&quot;)),&#10;    'MAX_FILE_SIZE_MB': 5,&#10;    'FACE_TOLERANCE': float(os.getenv(&quot;AI_FACE_TOLERANCE&quot;, &quot;0.6&quot;)),&#10;    'PLATE_CONFIDENCE_THRESHOLD': float(os.getenv(&quot;AI_PLATE_CONFIDENCE_THRESHOLD&quot;, &quot;0.5&quot;)),&#10;}" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Django settings for backend project.&#10;&quot;&quot;&quot;&#10;&#10;from pathlib import Path&#10;import os&#10;from dotenv import load_dotenv&#10;import dj_database_url&#10;&#10;# ------------------------------------&#10;# Paths / .env&#10;# ------------------------------------&#10;BASE_DIR = Path(__file__).resolve().parent.parent&#10;load_dotenv(BASE_DIR / &quot;.env&quot;)&#10;&#10;# ------------------------------------&#10;# Seguridad / Debug&#10;# ------------------------------------&#10;SECRET_KEY = os.getenv(&quot;SECRET_KEY&quot;, &quot;dev-only-not-secret&quot;)&#10;DEBUG = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;&#10;def _csv_env(name: str, default: list[str]) -&gt; list[str]:&#10;    raw = os.getenv(name, &quot;&quot;)&#10;    if not raw:&#10;        return default&#10;    return [x.strip() for x in raw.split(&quot;,&quot;) if x.strip()]&#10;&#10;if DEBUG:&#10;    # Desarrollo: abierto y cómodo&#10;    CORS_ALLOW_ALL_ORIGINS = True&#10;    CORS_ALLOW_CREDENTIALS = True&#10;    ALLOWED_HOSTS = [&quot;*&quot;]&#10;    SESSION_COOKIE_SAMESITE = &quot;Lax&quot;&#10;    CSRF_COOKIE_SAMESITE = &quot;Lax&quot;&#10;    SESSION_COOKIE_SECURE = False&#10;    CSRF_COOKIE_SECURE = False&#10;else:&#10;    # Producción: más estricto&#10;    CORS_ALLOW_ALL_ORIGINS = False&#10;    CORS_ALLOWED_ORIGINS = _csv_env(&#10;        &quot;CORS_ALLOWED_ORIGINS&quot;,&#10;        [&quot;https://tu-frontend.com&quot;]&#10;    )&#10;    CORS_ALLOW_CREDENTIALS = True&#10;    ALLOWED_HOSTS = _csv_env(&quot;ALLOWED_HOSTS&quot;, [&quot;127.0.0.1&quot;, &quot;localhost&quot;])&#10;    SESSION_COOKIE_SAMESITE = os.getenv(&quot;SESSION_COOKIE_SAMESITE&quot;, &quot;None&quot;)&#10;    CSRF_COOKIE_SAMESITE = os.getenv(&quot;CSRF_COOKIE_SAMESITE&quot;, &quot;None&quot;)&#10;    SESSION_COOKIE_SECURE = True&#10;    CSRF_COOKIE_SECURE = True&#10;&#10;CSRF_TRUSTED_ORIGINS = _csv_env(&#10;    &quot;CSRF_TRUSTED_ORIGINS&quot;,&#10;    [&#10;        &quot;http://127.0.0.1:8000&quot;,&#10;        &quot;http://localhost:8000&quot;,&#10;        &quot;http://127.0.0.1:5173&quot;,&#10;        &quot;http://localhost:5173&quot;,&#10;        &quot;http://127.0.0.1:3000&quot;,&#10;        &quot;http://localhost:3000&quot;,&#10;    ]&#10;)&#10;&#10;CSRF_COOKIE_NAME = &quot;csrftoken&quot;&#10;SECURE_PROXY_SSL_HEADER = (&quot;HTTP_X_FORWARDED_PROTO&quot;, &quot;https&quot;)&#10;SECURE_HSTS_SECONDS = 0 if DEBUG else 60 * 60 * 24 * 30  # 30 días&#10;SECURE_SSL_REDIRECT = not DEBUG&#10;&#10;# ------------------------------------&#10;# Apps&#10;# ------------------------------------&#10;INSTALLED_APPS = [&#10;    &quot;corsheaders&quot;,&#10;    &quot;django.contrib.admin&quot;,&#10;    &quot;django.contrib.auth&quot;,&#10;    &quot;django.contrib.contenttypes&quot;,&#10;    &quot;django.contrib.sessions&quot;,&#10;    &quot;django.contrib.messages&quot;,&#10;    &quot;django.contrib.staticfiles&quot;,&#10;    &quot;rest_framework&quot;,&#10;    &quot;rest_framework.authtoken&quot;,&#10;    &quot;django_filters&quot;,&#10;&#10;    &quot;api&quot;,  # tu app&#10;]&#10;&#10;# ------------------------------------&#10;# Middleware&#10;# ------------------------------------&#10;MIDDLEWARE = [&#10;    &quot;django.middleware.security.SecurityMiddleware&quot;,&#10;    &quot;whitenoise.middleware.WhiteNoiseMiddleware&quot;,&#10;    &quot;corsheaders.middleware.CorsMiddleware&quot;,&#10;    &quot;django.contrib.sessions.middleware.SessionMiddleware&quot;,&#10;    &quot;django.middleware.common.CommonMiddleware&quot;,&#10;    &quot;django.middleware.csrf.CsrfViewMiddleware&quot;,&#10;    &quot;django.contrib.auth.middleware.AuthenticationMiddleware&quot;,&#10;    &quot;django.contrib.messages.middleware.MessageMiddleware&quot;,&#10;    &quot;django.middleware.clickjacking.XFrameOptionsMiddleware&quot;,&#10;]&#10;&#10;ROOT_URLCONF = &quot;backend.urls&quot;&#10;&#10;TEMPLATES = [&#10;    {&#10;        &quot;BACKEND&quot;: &quot;django.template.backends.django.DjangoTemplates&quot;,&#10;        &quot;DIRS&quot;: [BASE_DIR / &quot;templates&quot;],&#10;        &quot;APP_DIRS&quot;: True,&#10;        &quot;OPTIONS&quot;: {&#10;            &quot;context_processors&quot;: [&#10;                &quot;django.template.context_processors.request&quot;,&#10;                &quot;django.contrib.auth.context_processors.auth&quot;,&#10;                &quot;django.contrib.messages.context_processors.messages&quot;,&#10;            ],&#10;        },&#10;    },&#10;]&#10;&#10;WSGI_APPLICATION = &quot;backend.wsgi.application&quot;&#10;&#10;# ------------------------------------&#10;DATABASES = {&#10;    &quot;default&quot;: dj_database_url.config(&#10;        env=&quot;DATABASE_URL&quot;,&#10;    )&#10;}&#10;&#10;# Configuraciones adicionales después&#10;_db_url = os.getenv(&quot;DATABASE_URL&quot;, &quot;&quot;)&#10;if &quot;:6543/&quot; in _db_url:&#10;    DATABASES[&quot;default&quot;][&quot;CONN_MAX_AGE&quot;] = 0&#10;else:&#10;    DATABASES[&quot;default&quot;][&quot;CONN_MAX_AGE&quot;] = 600&#10;&#10;# SSL para Supabase&#10;if &quot;supabase&quot; in _db_url:&#10;    DATABASES[&quot;default&quot;][&quot;OPTIONS&quot;] = {&#10;        &quot;sslmode&quot;: &quot;require&quot;&#10;    }&#10;# ------------------------------------&#10;# Password validators&#10;# ------------------------------------&#10;AUTH_PASSWORD_VALIDATORS = [&#10;    {&quot;NAME&quot;: &quot;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&quot;},&#10;    {&quot;NAME&quot;: &quot;django.contrib.auth.password_validation.MinimumLengthValidator&quot;, &quot;OPTIONS&quot;: {&quot;min_length&quot;: 8}},&#10;    {&quot;NAME&quot;: &quot;django.contrib.auth.password_validation.CommonPasswordValidator&quot;},&#10;    {&quot;NAME&quot;: &quot;django.contrib.auth.password_validation.NumericPasswordValidator&quot;},&#10;]&#10;&#10;# ------------------------------------&#10;# Localización&#10;# ------------------------------------&#10;LANGUAGE_CODE = &quot;es&quot;&#10;TIME_ZONE = &quot;America/La_Paz&quot;&#10;USE_I18N = True&#10;USE_TZ = True&#10;&#10;# ------------------------------------&#10;# Archivos estáticos (WhiteNoise)&#10;# ------------------------------------&#10;STATIC_URL = &quot;/static/&quot;&#10;STATIC_ROOT = BASE_DIR / &quot;staticfiles&quot;&#10;STATICFILES_STORAGE = &quot;whitenoise.storage.CompressedManifestStaticFilesStorage&quot;&#10;&#10;# ------------------------------------&#10;# DRF&#10;# ------------------------------------&#10;REST_FRAMEWORK = {&#10;    &quot;DEFAULT_PERMISSION_CLASSES&quot;: [&#10;        &quot;rest_framework.permissions.IsAuthenticated&quot;,&#10;    ],&#10;    &quot;DEFAULT_AUTHENTICATION_CLASSES&quot;: [&#10;        &quot;rest_framework.authentication.TokenAuthentication&quot;,&#10;        &quot;rest_framework.authentication.SessionAuthentication&quot;,&#10;    ],&#10;    &quot;DEFAULT_PAGINATION_CLASS&quot;: &quot;rest_framework.pagination.PageNumberPagination&quot;,&#10;    &quot;PAGE_SIZE&quot;: 25,&#10;    &quot;DEFAULT_FILTER_BACKENDS&quot;: [&#10;        &quot;django_filters.rest_framework.DjangoFilterBackend&quot;,&#10;        &quot;rest_framework.filters.SearchFilter&quot;,&#10;        &quot;rest_framework.filters.OrderingFilter&quot;,&#10;&#10;    ],&#10;&#10;}&#10;&#10;# ------------------------------------&#10;# Otros&#10;# ------------------------------------&#10;DEFAULT_AUTO_FIELD = &quot;django.db.models.BigAutoField&quot;&#10;&#10;# ------------------------------------&#10;# Frontend / Email (opcional)&#10;# ------------------------------------&#10;FRONTEND_URL = os.getenv(&quot;FRONTEND_URL&quot;, &quot;http://localhost:5173&quot;)&#10;DEFAULT_FROM_EMAIL = os.getenv(&quot;DEFAULT_FROM_EMAIL&quot;, &quot;no-reply@smart-condominium.local&quot;)&#10;&#10;EMAIL_BACKEND = os.getenv(&quot;EMAIL_BACKEND&quot;, &quot;django.core.mail.backends.smtp.EmailBackend&quot;)&#10;EMAIL_HOST = os.getenv(&quot;EMAIL_HOST&quot;, &quot;smtp.gmail.com&quot;)&#10;EMAIL_PORT = int(os.getenv(&quot;EMAIL_PORT&quot;, &quot;587&quot;))&#10;EMAIL_HOST_USER = os.getenv(&quot;EMAIL_HOST_USER&quot;, &quot;&quot;)&#10;EMAIL_HOST_PASSWORD = os.getenv(&quot;EMAIL_HOST_PASSWORD&quot;, &quot;&quot;)&#10;EMAIL_USE_TLS = os.getenv(&quot;EMAIL_USE_TLS&quot;, &quot;True&quot;) == &quot;True&quot;&#10;EMAIL_USE_SSL = os.getenv(&quot;EMAIL_USE_SSL&quot;, &quot;False&quot;) == &quot;True&quot;&#10;&#10;# ------------------------------------&#10;# Logging sencillo&#10;# ------------------------------------&#10;LOGGING = {&#10;    &quot;version&quot;: 1,&#10;    &quot;disable_existing_loggers&quot;: False,&#10;    &quot;formatters&quot;: {&#10;        &quot;verbose&quot;: {&quot;format&quot;: &quot;{levelname} {asctime} {module} {message}&quot;, &quot;style&quot;: &quot;{&quot;},&#10;    },&#10;    &quot;handlers&quot;: {&#10;        &quot;console&quot;: {&quot;class&quot;: &quot;logging.StreamHandler&quot;, &quot;formatter&quot;: &quot;verbose&quot;},&#10;    },&#10;    &quot;root&quot;: {&quot;handlers&quot;: [&quot;console&quot;], &quot;level&quot;: &quot;INFO&quot;},&#10;    &quot;loggers&quot;: {&#10;        &quot;django&quot;: {&quot;handlers&quot;: [&quot;console&quot;], &quot;level&quot;: &quot;INFO&quot;, &quot;propagate&quot;: False},&#10;        &quot;api&quot;: {&quot;handlers&quot;: [&quot;console&quot;], &quot;level&quot;: &quot;DEBUG&quot;, &quot;propagate&quot;: False},&#10;    },&#10;}&#10;&#10;SUPABASE_URL = os.getenv(&quot;SUPABASE_URL&quot;)&#10;SUPABASE_SERVICE_KEY = os.getenv(&quot;SUPABASE_SERVICE_ROLE_KEY&quot;)&#10;SUPABASE_STORAGE_BUCKET = os.getenv(&quot;SUPABASE_STORAGE_BUCKET&quot;, &quot;ai-detection-images&quot;)&#10;SUPABASE_STORAGE_URL = f&quot;{SUPABASE_URL}/storage/v1/object/public/{SUPABASE_STORAGE_BUCKET}&quot;&#10;&#10;# ------------------------------------&#10;# Configuración de IA&#10;# ------------------------------------&#10;AI_IMAGE_SETTINGS = {&#10;    'MAX_SIZE': (1920, 1080),&#10;    'THUMBNAIL_SIZE': (800, 600),&#10;    'JPEG_QUALITY': int(os.getenv(&quot;AI_JPEG_QUALITY&quot;, &quot;85&quot;)),&#10;    'MAX_FILE_SIZE_MB': 5,&#10;    'FACE_TOLERANCE': float(os.getenv(&quot;AI_FACE_TOLERANCE&quot;, &quot;0.6&quot;)),&#10;    'PLATE_CONFIDENCE_THRESHOLD': float(os.getenv(&quot;AI_PLATE_CONFIDENCE_THRESHOLD&quot;, &quot;0.5&quot;)),&#10;}&#10;&#10;# ------------------------------------&#10;# Configuración del microservicio de IA&#10;# ------------------------------------&#10;AI_MICROSERVICE_URL = os.getenv('AI_MICROSERVICE_URL', 'http://localhost:8001')&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>